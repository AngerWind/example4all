

#### TypeScript简介

1. TypeScript是JavaScript的超集。在 js中能用的在ts中都能用
2. ts对js中添加了类型, 所以在执行ts的时候需要先编译成指定版本的js

#### TypeScript 开发环境搭建



2. 安装Node.js

3. 使用npm全局安装typescript
   - 进入命令行
   - 输入：npm i -g typescript
   - 输入: tsc --version 来确认ts编译器的版本
   
4. 创建一个ts文件

5. 使用tsc对ts文件进行编译并执行
   - 进入命令行
   - 进入ts文件所在目录
   - 执行命令：tsc xxx.ts 将ts编译成js
   - 执行js代码

#### ts-node的使用

ts-node可以直接运行ts代码(也是编译成js然后给node执行)

`npm install -g ts-node`安装

`ts-node hello.ts` 执行ts

#### 类型

- 类型声明

  - 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错

    ```typescript
    let a: string;
    let b: boolean = true;
    function sum(a: number, b: number): number {return a+b} 
    ```

- 自动类型判断

  - TS拥有自动的类型判断机制

  - 当对变量的声明和赋值是同时进行的，可以省略类型, TS编译器会自动判断变量的类型

    ```ts
    let b = "hello" // 自动推断为string
    ```

    

- 类型：

  |   类型   |          例子           |                描述                |
  | :------: | :---------------------: | :--------------------------------: |
  |  number  |       1, -33, 2.5       |              任意数字              |
  |  string  |    'hi', "hi", `hi`     |             任意字符串             |
  | boolean  |       true、false       |         布尔值true或false          |
  |  字面量  |         其本身          |    限制变量的值就是该字面量的值    |
  |   any    |            *            |              任意类型              |
  | unknown  |            *            |           类型安全的any            |
  |   void   |    空值（undefined）    |       没有值（或undefined）        |
  |  never   |         没有值          |            不能是任何值            |
  |  object  |     {name:'孙悟空'}     |            任意的JS对象            |
  |  array   |         [1,2,3]         |             任意JS数组             |
  |  tuple   |          [4,5]          |   元素，TS新增类型，固定长度数组   |
  |   enum   |       enum{A, B}        |         枚举，TS中新增类型         |
  | 联合类型 |    string \| number     | 表示既可以是string, 又可以是number |
  |  symbol  | let s:symbol = Symbol() |                                    |

- number

  - ```typescript
    let decimal: number = 6;
    let hex: number = 0xf00d;
    let binary: number = 0b1010;
    let octal: number = 0o744;
    let big: bigint = 100n;
    ```

- boolean

  - ```typescript
    let isDone: boolean = false;
    ```

- string

  - ```typescript
    let color: string = "blue";
    color = 'red';
    
    let fullName: string = `Bob Bobbington`;
    let age: number = 37;
    let sentence: string = `Hello, my name is ${fullName}.
    
    I'll be ${age + 1} years old next month.`;
    ```

- 字面量

  - 也可以使用字面量去指定变量的类型，通过字面量可以**确定变量的取值范围**

  - ```typescript
    let a: 1; // a只能是1
    let color: 'red' | 'blue' | 'black' = "red";
    let num: 1 | 2 | 3 | 4 | 5 = 1;
    
    // 自动类型推断, 设置str的类型为"hello world"
    // const str: "hello world" = "hello world"
    const str = "hello world"
    ```

- any任意类型

  - ```typescript
    let d: any = 4;
    d = 'hello';
    d = true;
    
    let c; // c的类型为any
    
    // any可以赋值给任何类型, 不报错
    let c1:any = 1;
    let s:string = c1; // 不保存
    ```

- unknown 类型安全的任意类型

  - ```typescript
    let notSure: unknown = 4;
    notSure = 'hello';
    
    // unknown不能复制给其他类型的值, 如果需要赋值需要添加条件
    let a: unknown = "hello"
    let s: string;
    s = a // 报错
    if (typeof a === "string") {
        s = a; // 不报错
    }
    s = a as string; // 不报错
    s = <string> a; // 不报错
    ```

- void: 常常用在函数返回值, 表示函数没有返回值, 但是可以返回null和undefined

  - ```typescript
    let unusable: void = undefined;
    
    function fn(): void {
        // return "hello" // 不行
        return null; // 可以
        return undefined; // 可以
    }
    ```

- never: 常常用在函数返回值, 表示没有返回值, 即使null和undefined也不行

  - ```typescript
    // 常常用在一个报错的函数中
    function error(message: string): never {
      if(message === "xxx"){
          throw new Error(message);
      }
    }
    ```

- object

  - ```typescript
    // object的类型定义使用分号隔开, 对象定义使用逗号隔开
    
    let obj: object = {}; //现在obj只能是一个对象, 但是js中的对象是在是太复杂了, 所以没啥用
    
    // 有用的是要限制对象中有什么属性
    let obj: {name: string}  // 限制了obj只有一个name:string属性, 多了也不行, 少了也不行
    obj = {name: "aaa"}
    obj = {name: "aaa", age: 12} // 报错, 多了一个
    obj = {} // 报错
    
    // 加上问号, 表示属性可选
    let obj: {name: string; age?: number}  // 限制了obj有一个name:string属性, 同时有一个可选的age属性
    obj = {name: "aaa"} // 不报错
    obj = {name: "aaa", age: 12}  // 不报错
    
    // 限制了obj有一个name属性, 同时有多个key为string, value为any的其他属性
    let obj: {name: string; [propName: string]: any}
    obj = {name: "aaa", age: 12, sex: "nan"} // 不报错
    
    // 如果类型的属性写在多行, 可以不加分号
    // 函数可以使用定义的形式, 也可以使用箭头函数的形式
    let obj1: {
      name: string
      sayHi(name: string): void
      sayHi2: (name: string) => void
      [propName: string]: any
    };
    ```

- array

  - ```typescript
    let list: number[] = [1, 2, 3]; // 数组, 元素只能是number
    let list: Array<number> = [1, 2, 3]; // 与上面相同
    ```

- tuple

  - ```typescript
    let x: [string, number];
    x = ["hello", 10]; 
    ```

- 联合类型

  - ~~~js
    let x: string | number = "hello"; // 表示x可以是string类型或者number类型
    function haha(message: string): string | number {
      return "1";
    }
    
    let arr:(number | string)[] = ["a", 1, "b", "2"] // 数组, 元素可以是数字和字符串
    let arr: number | string[] // 数字和字符串数组
    ~~~
  
- enum

  - ```typescript
    // 枚举成员是有值的, 默认从0开始
    enum Color {
      Red, // 0
      Green, // 1
      Blue, // 2
    }
    enum Color {
      Red = 1, // 1
      Green,  // 2
      Blue, // 3
    }
    enum Color {
      Red = 1,
      Green = 2,
      Blue = 4,
    }
    ```
  - ```ts
  // 枚举的值还可以是字符串, 一旦设定枚举的值是字符串, 那么所有成员都必须要有初始值
    enum Direction {
        UP = "UP",
        DOWN = "DOWN",
        LEFT = "LEFT",
        RIGHT = "RIGHT"
    }
    ```
  
- 函数类型

  ```ts
  // 定义和赋值分开
  let d: (a:number, b: number) => number;
  d = function(n1: number, n2: number): number {
      return n1 + n2;
  }
  // 定义和赋值一起
  let d: (a:string, b: number) => number = function(n1: number, n2: number): number {
      return n1 + n2;
  }
  // 如果定义和赋值一起, 变量的类型可以省略, 上面的可以简写为如下
  let add = (n1: number, n2:number):number => {
      return a +b
  }
  ```
  
  
  
- 类型别名

  - ~~~ts
  // 这里只是别名, 并不会和go一样创建一个新的类型
    type myType = 1 | 2 | 3;
  let a: myTpye = 1;
    
    type myArr = (string, number)[]
    let arr: myArr = [1, "b"]
    ~~~
  
- 类型断言

  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：

    - 第一种

      - ```typescript
        let someValue: unknown = "this is a string";
        let strLength: number = (someValue as string).length;
        ```

    - 第二种

      - ```typescript
        let someValue: unknown = "this is a string";
        let strLength: number = (<string>someValue).length;
        ```

        

#### 函数的可选参数

```ts
// 函数有一个必选参数, n个可选的任意类型的参数
// 可选参数只能出现在参数列表的最后
function getHTTP(url: string, queryString?:any[]){}
```

#### 默认参数

```js
// 默认参数是js中的, 在ts中也能用
function add(n1:number = 1, n2:number = 2) {}
```





#### tsconfig.json编译选项

- 自动编译文件

  - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。**但是只能监视一个文件**

  - 示例：

    - ```powershell
      tsc xxx.ts -w
      ```
      

  ![image-20230328165552789](img/第一章：快速入门/image-20230328165552789.png)

- 自动编译/监视整个项目

  - 先在项目根目录下创建一个ts的配置文件 tsconfig.json, 当然也可以通过`tsc --init`来创建
  - tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译, 内容如下

    ~~~json
    {}
    ~~~

    上面即使是一个空的文件也能使用

    **使用`tsc`编译整个项目**

    **使用`tsc -w`编译并监视整个项目**

  - 配置选项：

    - include

      - 定义希望被编译文件所在的目录

      - 默认值：["\*\*/\*"]

      - 示例：

        - ```json
          "include":["src/**/*", "tests/**/*"]
          ```

        - 上述示例中，所有src目录和tests目录下的文件都会被编译

    - exclude

      - 定义需要排除在外的目录

      - 默认值：["node_modules", "bower_components", "jspm_packages"]

      - 示例：

        - ```json
          "exclude": ["./src/hello/**/*"]
          ```

        - 上述示例中，src下hello目录下的文件都不会被编译

    - extends

      - 定义当前文件继承其他配置文件中的配置

      - 示例：

        - ```json
          "extends": "./configs/base"
          ```

        - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息, 可以**避免重复配置**

    - files

      - 指定需要编译文件的列表, 与include类似，只有需要编译的文件少时才会用到

      - 示例：

        - ```json
          "files": [
              "core.ts",
              "sys.ts",
              "types.ts",
              "scanner.ts",
              "parser.ts",
              "utilities.ts",
              "binder.ts",
              "checker.ts",
              "tsc.ts"
            ]
          ```

        - 列表中的文件都会被TS编译器所编译

      - compilerOptions

        - 编译选项是配置文件中非常重要也比较复杂的配置选项

        - 在compilerOptions中包含多个子选项，用来完成对编译的配置

          - 项目选项

            - target

              - 设置ts代码编译的目标版本

              - 可选值：

                - 'es3'(默认), 'es5', 'es6', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'esnext'

              - 示例：

                - ```json
                  "compilerOptions": {
                      "target": "ES6"
                  }
                  ```

                - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

            - lib

              - 指定代码运行时所包含的库（宿主环境）(一般情况下不用修改)

              - 可选值：

                - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

              - 示例：

                - ```json
                  "compilerOptions": {
                      "target": "ES6",
                      "lib": ["ES6", "DOM"],
                      "outDir": "dist",
                      "outFile": "dist/aa.js"
                  }
                  ```

            - module

              - 设置编译后代码使用的模块化系统(导入导出)

              - 可选值：

                - 'none', 'commonjs', 'amd', 'system', 'umd', 'es6', 'es2015'(es2015和es6是一样的), 'es2020', 'esnext'

              - 示例：

                - ```typescript
                  "compilerOptions": {
                      "module": "CommonJS"
                  }
                  ```

            - outDir

              - 编译后文件的所在目录

              - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置

              - 示例：

                - ```json
                  "compilerOptions": {
                      "outDir": "./dist"
                  }
                  ```

                - 设置后编译后的js文件将会生成到dist目录

            - outFile(了解, 后续使用打包工具)

              - 将生成后的js文件合并为一个js文件

              - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中

              - 示例：

                - ```json
                  "compilerOptions": {
                      "outFile": "dist/app.js"
                  }
                  ```

            - rootDir

              - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录

              - 示例：

                - ```json
                  "compilerOptions": {
                      "rootDir": "./src"
                  }
                  ```

            - allowJs

              - 是否对目录下的 js文件编译, 默认为false, 如果为true那么就会将js文件也放到outDir目录下

            - checkJs

              - 检查目录下的js文件语法是否符合规范, 默认是false

              - 示例：

                - ```json
                  "compilerOptions": {
                      "allowJs": true,
                      "checkJs": true
                  }
                  ```

            - removeComments

              - 编译后是否删除注释
              - 默认值：false

            - noEmit

              - 只进行编译, 不生成编译后的js文件, 用于语法检查
              - 默认值：false

            - noEmitOnError

              - 有错误的情况下编译失败

                即如果ts中有不符合ts语法的, 但是在js中能执行的(不同类型的赋值), 默认也会编译过去

              - 默认值：false

            - sourceMap

              - 是否生成sourceMap
              - 默认值：false

              

          - 严格检查

            - strict
              
              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查, 是下面几个属性的总开关
            - alwaysStrict
              
              - 编译后的js文件是否使用严格模式, 默认为false
              
              - 当在js中使用了import后, 编译的js文件自动使用严格模式
              
              - 严格模式, 即在js文件开头添加"use strict";
              
                <img src="img/第一章：快速入门/image-20230328172602240.png" alt="image-20230328172602240" style="zoom: 50%;" />
            - noImplicitAny
              
              - 禁止隐式的any类型, 默认为false
              
              - 隐式类型
              
                ```ts
                let a; // a隐式为any
                function(a, b){} // a,b, 返回值隐式为any 
                ```
              
            - noImplicitThis
              
              - 禁止类型不明确的this
              
              - 当函数作为方法调用时, this指向调用对象, 当作为函数调用时, this指向window, 禁止使用这样类型不明确的this
              
                ![image-20230328173213144](img/第一章：快速入门/image-20230328173213144.png)
            - strictBindCallApply
              
              - 严格检查bind、call和apply的参数列表
            - strictFunctionTypes
              
              - 严格检查函数的类型
            - strictNullChecks
              
              - 必须对可能的空值机型检查, 下面这种情况下box1可能为null, 如果设置为true, 必须检查
              
                ![image-20230328173356495](img/第一章：快速入门/image-20230328173356495.png)
            - strictPropertyInitialization
              
              - 严格检查属性是否初始化
  
- 额外检查
          
  - noFallthroughCasesInSwitch
              - 检查switch语句包含正确的break
            - noImplicitReturns
              - 检查函数没有隐式的返回值
            - noUnusedLocals
              - 检查未使用的局部变量
            - noUnusedParameters
              - 检查未使用的参数
  
- 高级
          
  - allowUnreachableCode
              - 检查不可达代码
              - 可选值：
                - true，忽略不可达代码
                - false，不可达代码将引起错误
              
              

#### webpack

- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。

- 步骤：

  1. 初始化项目

     - 进入项目根目录，执行命令 ``` npm init -y```
       - 主要作用：创建package.json文件

  2. 下载构建工具

     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```
       - 共安装了7个包
         - webpack
           - 构建工具webpack
         - webpack-cli
           - webpack的命令行工具
         - webpack-dev-server
           - webpack的开发服务器
         - typescript
           - ts编译器
         - ts-loader
           - ts加载器，用于在webpack中编译ts文件
         - html-webpack-plugin
           - webpack中html插件，用来自动创建html文件
         - clean-webpack-plugin
           - webpack中的清除插件，每次构建都会先清除目录

  3. 根目录下创建webpack的配置文件webpack.config.js

     - ```javascript
       const path = require("path");
       const HtmlWebpackPlugin = require("html-webpack-plugin");
       const { CleanWebpackPlugin } = require("clean-webpack-plugin");
       
       module.exports = {
           optimization:{
               minimize: false // 关闭代码压缩，可选
           },
       
           entry: "./src/index.ts",
           
           devtool: "inline-source-map",
           
           devServer: {
               contentBase: './dist'
           },
       
           output: {
               path: path.resolve(__dirname, "dist"),
               filename: "bundle.js",
               environment: {
                   arrowFunction: false // 关闭webpack的箭头函数，可选
               }
           },
       
           resolve: {
               extensions: [".ts", ".js"]
           },
           
           module: {
               rules: [
                   {
                       test: /\.ts$/,
                       use: {
                          loader: "ts-loader"     
                       },
                       exclude: /node_modules/
                   }
               ]
           },
       
           plugins: [
               new CleanWebpackPlugin(),
               new HtmlWebpackPlugin({
                   title:'TS测试'
               }),
           ]
       
       }
       ```

  4. 根目录下创建tsconfig.json，配置可以根据自己需要

     - ```json
       {
           "compilerOptions": {
               "target": "ES2015",
               "module": "ES2015",
               "strict": true
           }
       }
       ```

  5. 修改package.json添加如下配置

     - ```json
       {
         ...略...
         "scripts": {
           "test": "echo \"Error: no test specified\" && exit 1",
           "build": "webpack",
           "start": "webpack serve --open chrome.exe"
         },
         ...略...
       }
       ```

  6. 在src下创建ts文件，并在并命令行执行```npm run build```对代码进行编译，或者执行```npm start```来启动开发服务器

     

#### Babel

- 经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。

  1. 安装依赖包：
     - ```npm i -D @babel/core @babel/preset-env babel-loader core-js```
     - 共安装了4个包，分别是：
       - @babel/core
         - babel的核心工具
       - @babel/preset-env
         - babel的预定义环境
       - @babel-loader
         - babel在webpack中的加载器
       - core-js
         - core-js用来使老版本的浏览器支持新版ES语法

  2. 修改webpack.config.js配置文件

     - ```javascript
       ...略...
       module: {
           rules: [
               {
                   test: /\.ts$/,
                   use: [
                       {
                           loader: "babel-loader",
                           options:{
                               presets: [
                                   [
                                       "@babel/preset-env",
                                       {
                                           "targets":{
                                               "chrome": "58",
                                               "ie": "11"
                                           },
                                           "corejs":"3",
                                           "useBuiltIns": "usage"
                                       }
                                   ]
                               ]
                           }
                       },
                       {
                           loader: "ts-loader",
       
                       }
                   ],
                   exclude: /node_modules/
               }
           ]
       }
       ...略...
       ```

     - 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。

#### tsconfig之moduleResolution详解

> 作用

moduleResolution：指定ts在处理import的时候按照 什么逻辑去查找对应的文件

> 模块解析策略

共有两种可用的模块解析策略：`Node` 和 `Classic`。
若未指定，默认值为 `Classic`。

> Classic 策略 

这种策略在以前是 TypeScript 默认的解析策略。

- 相对导入的模块是相对于导入它的文件进行解析的
  如 `/root/src/folder/A.ts` 文件里的 `import { b } from "./moduleB"` 会使用下面的查找流程
  - `/root/src/folder/moduleB.ts`
  - `/root/src/folder/moduleB.d.ts`

- 非相对模块的导入

  从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件

  如 `/root/src/folder/A.ts` 文件里的 `import { b } from "moduleB"` 会使用下面的查找流程

  - `/root/src/folder/moduleB.ts`
  - `/root/src/folder/moduleB.d.ts`
  - `/root/src/moduleB.ts`
  - `/root/src/moduleB.d.ts`
  - `/root/moduleB.ts`
  - `/root/moduleB.d.ts`
  - `/moduleB.ts`
  - `/moduleB.d.ts`
> Node策略

- typescript相对导入

  TypeScript 是模仿 Node.js 运行时的解析策略来在编译阶段定位模块定义文件。

  - TypeScript 在 Node 解析逻辑基础上增加了 TypeScript 源文件的扩展名（.ts，.tsx 和 .d.ts ）

  - TypeScript 在 package.json 里使用字段 types 来表示类似 main 的意义 - 编译器会使用它来找到要使用的 main 定义文件
    如 /root/src/moduleA.ts 文件里的 import { b } from "./moduleB" 会使用下面的查找流程

    `/root/src/moduleB.ts`
    `/root/src/moduleB.tsx`
    `/root/src/moduleB.d.ts`
    `/root/src/moduleB/package.json (如果指定了 types 属性)`
    `/root/src/moduleB/index.ts`
    ``/root/src/moduleB/index.tsx`
    `/root/src/moduleB/index.d.ts`

- typescript非相对导入

  如 `/root/src/moduleA.ts` 文件里的 `import { b } from "moduleB"` 会使用下面的查找流程

  `/root/src/node_modules/moduleB.ts`

  `/root/src/node_modules/moduleB.tsx`

  `/root/src/node_modules/moduleB.d.ts`

  `/root/src/node_modules/moduleB/package.json (如果指定了 types 属性)`

  `/root/src/node_modules/moduleB/index.ts`

  `/root/src/node_modules/moduleB/index.tsx`

  `/root/src/node_modules/moduleB/index.d.ts`

  `/root/node_modules/moduleB.ts`

  `/root/node_modules/moduleB.tsx`

  `/root/node_modules/moduleB.d.ts`

  `/root/node_modules/moduleB/package.json (如果指定了 types 属性)`

  `/root/node_modules/moduleB/index.ts`

  `/root/node_modules/moduleB/index.tsx`

  `/root/node_modules/moduleB/index.d.ts`

  `/root/node_modules/moduleB.ts`

  `/root/node_modules/moduleB.tsx`

  `/root/node_modules/moduleB.d.ts`

  `/root/node_modules/moduleB/package.json (如果指定了 types 属性)`

  `/root/node_modules/moduleB/index.ts`

  `/root/node_modules/moduleB/index.tsx`

  `/root/node_modules/moduleB/index.d.ts`

#### ts下关于一些包的说明
1. `npm install -g typescript`
   typescript是ts的编译器
2. `npm install -g ts-node`
   ts-node能够运行我们直接运行一个ts文件, 否则的话我们就只能先通过tsc将其编译成js文件, 然后通过node去执行了
   当然也可以将ts加入到package.json的scripts中
   ```json
   "scripts": {
      "start": "ts-node ./src/index.ts"
    }
   ```
3. `npm install -D @types/node`
   因为原生的node使用的是js, 而js是没有类型的, ts在使用他们的时候并不知道js中的类型
   为了能够让ts知道js中的类型, ts中有一种.d.ts的文件, 专门用于给js补全类型
   所有的用于补全类型的包都以@types开头

   

# 第二章：面向对象

面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。

- 举例来说：
  - 操作浏览器要使用window对象
  - 操作网页要使用document对象
  - 操作控制台要使用console对象

一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。

在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。

## 1、类（class）

要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。

- 定义类：

  - ```typescript
    class 类名 {
    	属性名: 类型;
    	
    	constructor(参数: 类型){
    		this.属性名 = 参数;
    	}
    	
    	方法名(){
    		....
    	}
    
    }
    ```

- 示例：

  - ```typescript
    class Person{
        name: string;
        age: number;
    
        constructor(name: string, age: number){
            this.name = name;
            this.age = age;
        }
    
        sayHello(){
            console.log(`大家好，我是${this.name}`);
        }
    }
    ```

- 使用类：

  - ```typescript
    const p = new Person('孙悟空', 18);
    p.sayHello();
    ```

## 2、面向对象的特点

- 封装

  - 对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装

  - **默认情况下，对象的属性是可以任意的修改的**，为了确保数据的安全性，在TS中可以对属性的权限进行设置

  - 只读属性（readonly）：

    - **表示只读, 用来防止在构造函数之外对属性进行赋值, 可以有默认值, 只能修饰属性**

  - TS中属性具有三种修饰符：

    - public（默认值），可以在类、子类和对象中修改
    - protected ，可以在类、子类中修改
    - private ，可以在类中修改

  - 示例：

    - public

      - ```typescript
        class Person{
            public readonly name: string = "hello"; // 写或什么都不写都是public
            public age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以在类中修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 可以通过对象修改
        ```

    - protected

      - ```typescript
        class Person{
            protected name: string;
            protected age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

    - private

      - ```typescript
        class Person{
            private name: string;
            private age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中不能修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

  - 属性存取器(getter setter)

    - 对于一些不希望被任意修改的属性，可以将其设置为private

    - 直接将其设置为private将导致无法再通过对象修改其中的属性

    - 我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器

    - 读取属性的方法叫做setter方法，设置属性的方法叫做getter方法

    - 示例：

      - ```typescript
        class Person{
            private _name: string;
        
            constructor(name: string){
                this._name = name;
            }
        
            get name(){
                return this._name;
            }
        
            set name(name: string){
                this._name = name;
            }
        
        }
        
        const p1 = new Person('孙悟空');
        console.log(p1.name); // 通过getter读取name属性
        p1.name = '猪八戒'; // 通过setter修改name属性
        ```

  - 静态属性

    - 静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用

    - 静态属性（方法）使用static开头

    - 示例：

      - ```typescript
        class Tools{
            static PI = 3.1415926;
            
            static sum(num1: number, num2: number){
                return num1 + num2
            }
        }
        
        console.log(Tools.PI);
        console.log(Tools.sum(123, 456));
        ```

  - this

    - 在类中，使用this表示当前对象

- 继承

  - 继承时面向对象中的又一个特性

  - 通过继承可以将其他类中的属性和方法引入到当前类中

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

  - 通过继承可以在不修改类的情况下完成对类的扩展

  - 重写

    - 发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        
            run(){
                console.log(`子类中的run方法，会重写父类中的run方法！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

      - 在子类中可以使用super来完成对父类的引用

  - 抽象类（abstract class）

    - 抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例

    - ```typescript
      abstract class Animal{
          abstract run(): void;
          bark(){
              console.log('动物在叫~');
          }
      }
      
      class Dog extends Animals{
          run(){
              console.log('狗在跑~');
          }
      }
      ```

    - 使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现
    
    

## 3、接口（Interface）

接口的作用主要是限制结构和继承

- 限制对象结构

  - ```typescript
    interface Person{
        name: string;
        sayHello():void;
    }
    let obj:Person = {
        name: "hello",
        sayHello() {console.log("hello")}
    }
    ```
    
  
- 继承

  ```js
  class Student implements Person{
  	private name: string;
      constructor(name: string) {
          this.name = name;
  	}
      sayHello() {
          console.log('大家好，我是'+this.name);
      }
  }
  let stu = new Student("zhangsan");
  ```

- **接口在限制结构上和type别名还是一样的**

  ```ts
  type Person1 = {
    name: string;
    say():void
  }
  let a: Person1 = {
    name: "张三",
    say() { },
    // sex: "nan" // 不能再有其他属性
  }
  interface Person2  {
    name: string;
    say():void
  }
  let b: Person2 = {
    name: "张三",
    say() { },
    // sex: "nan" // 不能再有其他属性
  }
  ```

  

  

## 4、泛型（Generic）

定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。

- 举个例子：

  - ```typescript
    function test(arg: any): any{
    	return arg;
    }
    ```

  - 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型

  - 使用泛型：

  - ```typescript
    function test<T>(arg: T): T{
    	return arg;
    }
    ```

  - 这里的```<T>```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。

  - 那么如何使用上边的函数呢？

    - 方式一（直接使用）：

      - ```typescript
        test(10)
        ```

      - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式

    - 方式二（指定类型）：

      - ```typescript
        test<number>(10)
        ```

      - 也可以在函数后手动指定泛型

  - 可以同时指定多个泛型，泛型间使用逗号隔开：

    - ```typescript
      function test<T, K>(a: T, b: K): K{
          return b;
      }
      
      test<number, string>(10, "hello");
      ```

    - 使用泛型时，完全可以将泛型当成是一个普通的类去使用

  - 类中同样可以使用泛型：

    - ```typescript
      class MyClass<T>{
          prop: T;
      
          constructor(prop: T){
              this.prop = prop;
          }
      }
      ```

  - 除此之外，也可以对泛型的范围进行约束

    - ```typescript
      interface MyInter{
          length: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length;
      }
      ```

    - 使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。
    
  - 还可以为泛型指定默认的类型
  
    ~~~ts
    function test<T = number>(arg: T): T{
    	return arg;
    }
    test(10) // 在没有显示指定泛型的时候, 同时也无法通过参数来推断泛型的时候, 将会使用默认的泛型
    ~~~
  
    

#### 类型兼容性

类型兼容性即鸭子类型, 如果两个对象具有相同的结构, 那么会被认为是同一类型
```js
class Point(x:string, y:string)
class Point2D(x:string, y:string)
const p:Point = new Point2D() // 没问题
```



#### .d.ts文件的说明

我们现在所使用的的ts都是有类型的, 但是如果在ts中应用js, js是没有类型的, 所以ts会将js中的所有都设置为any类型, 使得我们在使用项目原来的js, 或者使用第三方的js包的时候, 无法知道具体的类型

所以ts就搞了一个.d.ts的文件功能, 该文件能够给已经存在的js文件中的对象设置类型, 我们能够给自己项目中原来的js添加上类型, 原来通过js发布的第三方包也能够添加上他们自己的类型, 使得ts能够利用

> 第三方类库中的.d.ts

第三方类库中的.d.ts文件又分为两种:

- 内置库的.d.ts文件, 即ts为js运行时可用的所有的标准化内置api都提供了声明文件, 比如window, document等bom, dom api都有对应的类型声明

- 第三方库中的.d.ts文件

  第三方库的.d.ts文件通过两种方式来提供类型定义文件

  - 第三方库自带的类型声明文件

    当ts在导入一个库的时候, 回去package.json中查找`typings`字段或者`types`字段, 该字段用于指定了当前模块的.d.ts文件

    <img src="img/第一章：快速入门/image-20230330003214146.png" alt="image-20230330003214146" style="zoom:50%;" />

    ![image-20230330002428179](img/第一章：快速入门/image-20230330002428179.png)

  - 如果第三方库中没有自带.d.ts文件, 那么加载一个模块的时候, 就会去`node_module/@types`目录下根据模块名去查找对应的.d.ts文件, 并将他们全部加载进来

    其中node_module/@types这个路径是默认规定的, 这个路径是专门保存第三方模块的.d.ts文件的

    比如在`npm install -D lodash`的时候,发现lodash这个模块没有自带.d.ts文件, 那么vscode就会提示你需要通过`npm install -D @types/lodash`来安装他的类型定义文件

    模块与类型定义文件的规律一般是前面加@types, 比如lodash和@types/lodash, react和@types/react

    ts专门提供了一个网页来查询第三方模块的类型定义文件`www.typescriptlang.org/dt`

> 为自己项目中的js文件创建.d.ts文件

比如我有一个utils.js文件, 内容如下:

~~~js
let count = 10;
const age = 12;
let songName = "痴心绝对";
let position = {
  x: 0,
  y: 0,
};

let obj = {
  x: 0,
  add: function () {
    x += 1;
  },
};

function add(x, y) {
  return x + y;
}

function changeDirection(direction) {
  console.log(direction);
}

export { age, count, songName, position, add, changeDirection, obj };

~~~

为这个js文件添加上类型, 就要在同样的目录创建一个同名的utils.d.ts文件, 内容如下

~~~ts
// declare表示为js中的一个变量/函数添加上类型
// 被添加上类型的变量/函数需要使用export导出才能够被使用
// 所以可以在declare的时候使用export
// 也可以先declare, 最后使用export{...}一起导出
/**
 * count
 */
export declare let count: number; // 声明count的类型为number

/**
 * age
 */
export declare const age: 12;
/**
 * songName
 */
export declare let songName: string; // 声明songName的类型为string

/**
 * position
 */
// 方式1
export interface Position {
  // 这个Position接口视情况导出与否都可以
  // 注意这里不是为变量添加类型,而是创建了一个新的接口
  x: number;
  y: number;
}
export declare let position: Position; // 给position添加上接口类型

// 方式2
// export declare let position: { // 使用对象类型
//   x: number,
//   y?: number // 问号表示可选
// }

/**
 * add
 */
// 方式1
export declare function add(x: number, y: number): number; //给add添加上类型
// !!!如果add函数支持重载, 那么为add添加多个类型也是可以的!!!
export declare function add(x: string, y: string): string;

// 方式2: 使用箭头函数, 注意这里的const
// export declare const add: (x: number, y: number) => number;

// 方式3: 使用type别名
// type addType = (x: number, y: number) => number; // 这里创建了一个新的类型别名
// export declare const add: addType; // 通过类型别名也可以

/**
 * changeDirection
 */
// 这里也可以使用函数定义, 箭头函数, 类型别名
export declare function changeDirection(
  direction: "up" | "down" | "left" | "right"
): void;

// 定义了一个接口, 可以视情况是否导出, 如果导出了, 那么ts就可以使用该类型
interface Peopele {
  name: string;
  age: number;
}

// 定义了一个类, 可以视情况是否导出, 如果导出了, 那么ts就可以使用该类型
declare class Student implements Peopele {
  public name: string;
  public age: number;
  say(): void;
}
~~~

上面js文件中使用的是ems的导出方式, 所以.d.ts文件也要使用ems的导出方式
如果js文件使用的是commonjs的导出方式, 那么.d.ts文件也要使用commonjs的导出方式, 语法参考如下

```ts
// https://segmentfault.com/a/1190000009247663
 declare module "abcde" { // 这里的"abcd"可以乱写类似
   export let a: number
   export function b(): number
   export let c: {
     let cd: string
   }
 }
```

如果导出的本身就是一个函数

```js
  let app = require("app")
  app()
```

 可以使用如下导出

  ```ts
declare module "app" {
   function aaa(some:number):number
    export=aaa
}
  ```





