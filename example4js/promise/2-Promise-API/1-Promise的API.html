<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promise API</title>
  </head>
  <body>
    <script>
      /**
            构造函数: Promise(executor){}
                1. executor函数: (resolve, reject) => {}, executor是同步执行的, 然后再executor内部执行异步操作
                2. resolve函数: 在内部会调用value=>{}函数
                3. reject函数: 在内部会调用reason=>{}函数
                resolve和reject都可以在调用时传递参数, 该参数会被传递给onResolved / onRejected函数

            Promise.prototype.then方法: (onResolved, onRejected) => {}
                1. onResolved函数: 在resolve内部被调用, 可以通过参数接收resolve传递的参数
                2. onRejected函数: 在reject内部被调用, 可以通过参数接收reject传递的参数 
                都可以通过参数来接收resolve/reject传递过来的数据
                都返回一个新的Promise对象

            Promise.prototype.catch 方法: (onRejected) => {}  
                1. onRejected 函数: 失败的回调函数 (reason) => {}
                    then()的语法糖, 相当于: then(undefined, onRejected)   
    */

      p = new Promise((resolve, reject) => {
        // 这段代码被立即同步调用
        console.log("hello");
        fs.readFile("./resource/content.tx", (err, data) => {
          //如果出错
          if (err) {
            reject(err); // 修改PromiseState为reject
          }
          //如果成功
          resolve(data); // 修改PromiseState为resolve
        });
      }).then(
        (value) => {
          console.log(value.toString());
        },
        (reason) => {
          console.log(reason);
        }
      );

      new Promise((resolve, reject) => {
        reject("erro");
      }).catch((reson) => {
        console.log(err);
      });

      /**
       * resolve是Promise函数的方法,不属于实例对象,  传入参数, 返回一个Promise对象
       *    如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象
       *    如果传入的参数为 Promise 对象, 则返回的Promise对象决定了返回的promise对象
       *
       *    作用是快速返回一个成功的对象
       */
      let p1 = Promise.resolve(521);
      console.log(p1);

      let p2 = Promise.resolve(
        new Promise((resolve, reject) => {
          // resolve('OK');
          reject("Error");
        })
      );
      console.log(p2);

      /**
       * reject是Promise函数的方法,不属于实例对象,  传入参数, 返回一个失败Promise对象
       *    不管传入的是非Promise对象还是Promise对象都返回一个失败的Promise对象
       *
       *    作用是快速返回一个失败 的对象
       */
      let s1 = Promise.reject(100);
      console.log(s1);

      let s2 = Promise.reject(
        new Promise((resolve, reject) => {
          resolve("erro");
        })
      );
      console.log(s2);

      /**
       * all方法是Promise函数的方法, 接收一个Promise数组
       *    如果这一组Promise都为成功, 就返回一个新的成功的Promise对象
       *    PromiseResult是一个数组, 保存着所有Promise的结果
       *
       *    只要有一个失败的Promise对象, 就返回一个新的成功的Promise对象
       *    PromiseResult就是失败的Promise的结果
       */
      let pa1 = new Promise((resolve, reject) => {
        resolve("OK");
      });
      let pa2 = Promise.reject("Error");
      let pa3 = Promise.resolve("Oh Yeah");
      const result = Promise.all([pa1, pa2, pa3]);

      console.log(result);

      /**
       * race方法是Promise函数的方法, 接收一个Promise数组
       *    返回一个新的 promise, 第一个完成操作的 promise 对象的的结果状态就是最终的结果状态
       */
      let pb1 = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("OK");
        }, 1000);
      });
      let pb2 = Promise.resolve("Success");
      let pb3 = Promise.resolve("Oh Yeah");
      const resultb = Promise.race([pb1, pb2, pb3]);
      console.log(resultb);
    </script>
  </body>
</html>
