{
	"compiler": {
		"version": "0.8.17+commit.8df45f5f"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "boo",
				"outputs": [],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "foo",
				"outputs": [],
				"stateMutability": "view",
				"type": "function"
			}
		],
		"devdoc": {
			"kind": "dev",
			"methods": {},
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"notice": "- 父合约标记为 virtual 函数可以在继承合约里重写(overridden)以更改他们的行为。 重写的函数需要使用关键字 override 修饰。 - 重写函数只能将函数的可见性从 external 更改为 public 。 - 重写函数只能将函数的可变性按照以下顺序更改为更严格的一种：  nonpayable 可以被 view 和 pure 覆盖。  view 可以被 pure 覆盖。  payable 是一个例外，不能更改为任何其他可变性。 - 如果函数没有标记为 virtual ， 那么派生合约将不能重写该方法 - 已重写的方法仍然可以使用(super. 或者 父合约.) 来调用 - private 的函数是不可以标记为 virtual 的。 - 除接口之外（因为接口会自动作为 virtual ），没有实现的函数必须标记为 virtual",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"合约/_11_合约_继承_函数重写.sol": "Base"
		},
		"evmVersion": "london",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"合约/_11_合约_继承_函数重写.sol": {
			"keccak256": "0x2fbc93b037dffbe81d8c1ce710bbaeb8ff7ce6cfbedc3fabb61f6f33c81fcd42",
			"license": "GPL-3.0",
			"urls": [
				"bzz-raw://3d8d06a7ee712603f3308b8940f0aed844e3d0722d5fc80ea664ce3d5551279b",
				"dweb:/ipfs/QmeGrYoqpZjX3u6U7T8shfazoY1qpWQZVZiJGXtiubEYYb"
			]
		}
	},
	"version": 1
}