// SPDX-License-Identifier:GPL-3.0

pragma solidity ^0.8.17;

/**
 * 静态类型
 *      对于uint<M>, 全部高位补0
 *      对于int<M>, 正数高位补0, 负数高位补0xff
 *      对于bool, true表示1, false表示0, 高位补0
 *      对于address, 高位补0
 *      对于合约类型, 按照地址类型编码
 *      对于枚举, 转换为uint8后编码
 *      对于bytes<M>, 低位补上使其高度为32字节倍数的最少的0
 *      对于function, 一个20字节的地址之后紧跟4字节的函数选择器, 低位补0
 *              函数选择器: 对函数前面进行keccak256哈希, 然后取前四字节
 *                  bytes4(keccak256("foo(uint256,address,string,uint256[2])")
 *
 *      对于任意静态类型的T的定长数组T[k], 现将长度编码, 然后对每个元素进行编码
 *
 * 动态类型
 *      对于string, 将其转换为utf8, 然后编码其utf8字节长度, 再然后将utf8字节码按照bytes对待
 *      对于bytes, 现将字节长度进行编码, 然后紧跟字节码序列, 低位补0
 *      对于任意类型T的变长数组T[], 先对长度进行编码, 然后元素按照abi.encode(T1, T2, ..., Tk)进行编码(所有元素被当做tuple对待)
 *      对于动态类型T的定长数组T[k], 元素按照abi.encode(T1, T2, ..., Tk)进行编码(所有元素被当做tuple对待)
 *      对于结构体类型, 被按照tuple对待, 所以结构体根据其属性可以是动态类型也可以是静态类型

 *      对于tuple(T1,...,Tk)的编码, 等于abi.encode(T1, T2, ..., Tk), 同时如果tuple中全是静态类型, 那么这个tuple被当做静态类型对待
 *      如果tuple中有一个动态类型, 那么这个tuple被按照动态类型对待
 *
 *
 * abi.encode的编码规则:
    从第一个参数开始依次进行如下判断
 *      1. 如果碰到静态类型的参数, 直接编码
 *      2. 如果配到动态类型的参数, 先在参数位置留下32字节, 表示这个动态参数的数据的位置(他的数据从第几个字节开始)
 *          等所有参数都编码完成之后, 再按照顺序把动态类型参数的数据部分依次添加在后面
 *
 */

contract Tester {
    enum ActionChoices {
        GoLeft,
        GoRight,
        GoStraight,
        SitStill
    }
    struct Person {
        address addr;
        uint8 age;
        bool sex;
    }
    struct Student {
        address addr;
        uint8 age;
        bool sex;
        string name;
    }

    function encode()
        public
        view
        returns (bytes memory result, bytes memory result2)
    {
        bytes4 fixedBytes = 0x12341234;
        uint[3] memory fixedUint = [uint(10), 1, 2];

        bytes memory b = new bytes(4);
        b[0] = 0x12;
        b[1] = 0x15;
        b[2] = 0x12;
        b[3] = 0x14;

        uint[] memory list = new uint[](3); // 任意类型T的变长数组 T[]
        list[0] = 1;
        list[1] = 12;
        list[2] = 13;

        string[2] memory strings = ["hello", "world"]; // 任意动态类型T的定长数组T[k]

        result = abi.encode(
            uint(10), // uint<M>
            uint8(10),
            int(-1), // int<M>
            uint(10),
            true,
            Student(address(this), 12, true, "zhangsan"),
            address(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF), // 地址, 高位补0
            this // 合约类型, 按照地址类型编码
        );
        /**
        0x000000000000000000000000000000000000000000000000000000000000000a // uint(10)
          000000000000000000000000000000000000000000000000000000000000000a // uint8(10),
          ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int(-1)
          000000000000000000000000000000000000000000000000000000000000000a // uint(10)
          0000000000000000000000000000000000000000000000000000000000000001 // true
          0000000000000000000000000000000000000000000000000000000000000100 // Student类型, 因为其中的有string属性, 所以被当做动态类型对待, 这32字节指示student的数据部分从整个结构的第1*16*16个字节开始 
          000000000000000000000000dcad3a6d3569df655070ded06cb7a1b2ccd1d3af // address
          000000000000000000000000d9145cce52d386f254917e481eb44e9943f39138 // this
           // student动态类型的数据部分, 被放在整个编码的最后, 整个student的编码结构等同于abi.encode(addr, age, sex, name)
          000000000000000000000000d9145cce52d386f254917e481eb44e9943f39138 // addr属性
          000000000000000000000000000000000000000000000000000000000000000c // age属性
          0000000000000000000000000000000000000000000000000000000000000001 // sex属性
          0000000000000000000000000000000000000000000000000000000000000080 // name属性, 因为string是动态属性, 所以这一行表示name属性的数据部分在当前编码(abi.encode(addr, age, sex, name))的第8*16字节开始
          0000000000000000000000000000000000000000000000000000000000000008 // name属性的数据部分, 这部分表示name属性转换为utf8后的字节长度, 表示转换为utf8后占字节
          7a68616e6773616e000000000000000000000000000000000000000000000000 // name的utf8字节部分, 低位补0
        */

        result2 = abi.encode(
            ActionChoices.GoRight, // 枚举, 转换为uint8后编码
            fixedBytes, // bytes<M>
            fixedUint, // 静态类型的定长数组T[k]
            Person(address(this), 18, true), // 全是静态类型的结构体, 被当做静态类型对待
            "this is a string", // 字符串, 转换为utf8后按照bytes对待
            b, // bytes
            list, // T[]
            strings
        );
        /**
        0x0000000000000000000000000000000000000000000000000000000000000001 // enum转换为uint8
          1234123400000000000000000000000000000000000000000000000000000000 // bytes<M>, 直接编码, 低位补0
          000000000000000000000000000000000000000000000000000000000000000a // 静态类型的定长数组T[k], [uint(10), 1, 2], 依次编码
          0000000000000000000000000000000000000000000000000000000000000001
          0000000000000000000000000000000000000000000000000000000000000002
          000000000000000000000000d9145cce52d386f254917e481eb44e9943f39138 // Person, 因为内部全是静态属性, 所以被当做静态类型对待, 直接编码, 这部分表示addr属性
          0000000000000000000000000000000000000000000000000000000000000012 // age属性
          0000000000000000000000000000000000000000000000000000000000000001 // sex属性
          0000000000000000000000000000000000000000000000000000000000000180 // string, 这部分表示string的数据部分从1*16*16+8*16字节开始
          00000000000000000000000000000000000000000000000000000000000001c0 // bytes, 这部分表示bytes的数据部分从1*16*16+12*16字节开始
          0000000000000000000000000000000000000000000000000000000000000200 // T[], 这部分表示T[]的数据部分从2*16*16字节开始
          0000000000000000000000000000000000000000000000000000000000000280 // 动态类型T的定长数组T[k], 这部分表示T[]的数据部分从2*16*16+8*16字节开始
          0000000000000000000000000000000000000000000000000000000000000010 // string的数据部分, 这部分表示string转换为utf8后占的字节长度, 占16字节
          74686973206973206120737472696e6700000000000000000000000000000000 // string的utf8编码, 低位补0
          0000000000000000000000000000000000000000000000000000000000000004 // bytes的数据部分, 这部分表示bytes的长度4个字节
          1215121400000000000000000000000000000000000000000000000000000000 // bytes的字节编码
          0000000000000000000000000000000000000000000000000000000000000003 // T[]的数据部分, 这部分表示T[]中一共3个元素
          0000000000000000000000000000000000000000000000000000000000000001 // T[0]
          000000000000000000000000000000000000000000000000000000000000000c // T[1]
          000000000000000000000000000000000000000000000000000000000000000d // T[2]
            // T[k]的数据部分
          0000000000000000000000000000000000000000000000000000000000000040 // 碰到的是第一个string, 所以当前32字节表示第一个string的数据位置从当前结构(abi.encode(str1, str2))的第4*16直接开始
          0000000000000000000000000000000000000000000000000000000000000080 // 碰到的是第二个string, 所以当前32字节表示第二个string的数据位置从当前结构(abi.encode(str1, str2))的第8*16直接开始
          0000000000000000000000000000000000000000000000000000000000000005 // 第一个string的数据部分, 这部分表示string被utf8编码后的字节长度
          68656c6c6f000000000000000000000000000000000000000000000000000000 // 第一个string直接转换为utf8的字节数据, 低位补0
          0000000000000000000000000000000000000000000000000000000000000005 // 第二个string的数据部分, 这部分表示string被utf8编码后的字节长度
          776f726c64000000000000000000000000000000000000000000000000000000 // 第二个string直接转换为utf8的字节数据, 低位补0
        */
    }
}
